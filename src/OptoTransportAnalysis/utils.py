from tkinter import filedialog as fd
from os import listdir
from os.path import splitext
from json import dump, load
import pptx
from pptx.util import Inches
from cycler import cycler
from .Optics import OpticsData, defined_sum_cosine_windows
from pandas import DataFrame
from numpy import mean, zeros, array


#### Utility variables -------------------------------------------------------

## Dimensions of relevant quantities in a powerpoint
prs_width = Inches(13.333)
prs_height = Inches(7.5)
pt18_height = Inches(1/4)

## Default plotting parameters to use
default_rcParams = {'axes.labelsize' : 14,
                    'axes.titlesize' : 16,
                    'axes.titleweight' : 2,
                    'axes.formatter.use_mathtext' : False,
                    'axes.prop_cycle' : cycler(color=['red', 'orange', 'gold', 'green', 'blue', 'indigo', 'violet']),
                    'axes.labelpad' : 10,
                    'lines.linewidth' : 0.8,
                    'legend.fontsize' : 8,
                    'legend.fancybox' : False,
                    'legend.shadow' : False,
                    'legend.title_fontsize' : 14,
                    'savefig.dpi' : 1200,
                    'savefig.transparent' : True,
                    'savefig.format' : 'png',
                    'savefig.bbox' : 'tight',
                    'figure.dpi' : 200,
                    'figure.figsize' : (6,4),
                    'xtick.labelsize' : 12,
                    'ytick.labelsize' : 12}

defined_sum_cosine_windows_names = defined_sum_cosine_windows.keys()


#### Utility functions -------------------------------------------------------

def dump_to_json_file(dict, filename):
    """
    Dump a dict into a .json file.

    Parameters
    ----------
    dict : dict
        Dict being written to .json file
    
    filename : str
        Name of file to write to

    Returns
    -------
    N/A
    """
    with open(filename, "w") as file:
        dump(dict, file)
    return

def create_metadata_from_dict(dict_to_write, initial_dir=""):
    """
    Create a .json metadata file from a dict.

    Useful if given data from someone else, if forgot to record a 
    metadata file when first acquiring data, or if associated 
    metadata file is lost.

    Parameters
    ----------
    dict_to_write : dict
        Dict being written to .json file

    initial_dir : str, default=""
        Directory to begin search from. On function call, a 
        tkinter.filedialog GUI is opened to select existing data file 
        to associate the new metadata file with. 

    Returns
    -------
    N/A
    """
    # Prompt user to select file with tkinter.filedialog GUI
    prompt_str = "Please select the file you wish to generate metadata for"
    filename = fd.askopenfilename(title=prompt_str, initialdir=initial_dir)

    # Solve for .json filename and dump to .json format
    filename_json = splitext(filename)[0] + '.json'
    dump_to_json_file(filename_json, dict_to_write)
    return


def org_csv_by_frame(file):
    """
    Overwrite a .csv file for a spectrum generated by LightField when doing 
    batch conversion.

    Useful if you took a spectrum from LightField and forgot to record it using
    standard formatting. LightField puts all intensities in one column and has
    another column named "Frame" rather than putting the intensity
    corresponding to each frame in a separate column. This function just moves
    the intensities into separate columns with a single wavelength column, i.e.,
    the standard format for OpticsData.

    Parameters
    ----------
    file : str
        Name of the .csv file

    Returns
    -------
    N/A

    Notes
    -----
    Overwrites the .csv file -- be careful!
    """
    dat = OpticsData(file)
    num_frames = dat.data['Frame'].max()
    scan_length = len(dat.data.loc[lambda df: df['Frame'] == 1])
    df = DataFrame()
    df['Wavelength'] = dat.data.loc[lambda df: df['Frame'] == 1]['Wavelength']
    for i in range(num_frames):
        df[f'Intensity_{i+1}'] = dat.data.loc[lambda df: df['Frame'] == (i+1)]['Intensity'].values
    df.to_csv(file)
    return

def create_summary_slide(prs, fig_name, run_title=None, 
                         custom_title=None, comment_txt=None):
    """
    Add a brief summary slide containing a figure and comment to an 
    existing powerpoint presentation.

    Parameters
    ----------
    prs : pptx.Presentation
        Existing PowerPoint presentation to edit.

    fig_name : path, path-like str
        Directory at which the figure to be put in the slide can be found.

    run_title : str, optional
        The title of the run in the Data object from which data is 
        being plotted. If given, sets the title of the slide to contain 
        the name of the data file.

    custom_title : str, optional
        If run_title not given, can also give a custom title. Useful if 
        plotted data comes from multiple datasets, etc. If both run_title
        and custom_title are given, custom_title takes precedence.

    comment_txt : str, optional
        Optional comment which can be added to the slide.

    Returns
    -------
    slide : ?
        Unsure of the exact type of this object, but seems to be a 
        reference to the created slide such that edits can be made 
        after creation.

    title : ?
        Also unsure of the exact type of this object, but seems to be a
        reference to the title of the slide such that edits can be made
        after creation.

    figure : ?
        Also unsure of the exact type of this object, but seems to be a
        reference to the figure of the slide such that edits can be made
        after creation.
    
    comment : ?
        Also unsure of the exact type of this object, but seems to be a
        reference to the comment of the slide such that edits can be made
        after creation.

    Notes
    -----
    For more information on the python-pptx package, look to
    https://python-pptx.readthedocs.io/en/latest/index.html
    """
    # Create slide using blank layout option
    blank = prs.slide_layouts[6]
    slide = prs.slides.add_slide(blank)

    # Give the slide a title
    # -- If run_title given and custom_title not given, set run_title as title
    # -- If custom_title given, set custom_title as title
    # -- Else, add default title to be edited later
    title = slide.shapes.add_textbox(left=0, top=0, width=prs_width, height=2*pt18_height)
    if run_title != None and custom_title == None:
        title.text = run_title
    elif (run_title == None and custom_title != None) or (run_title != None and custom_title != None):
        title.text = custom_title
    else:
        title.text = "Add title"

    # Add a figure to the slide and center it
    figure = slide.shapes.add_picture(image_file=fig_name, top=title.height, 
                                      left=0, height=prs_height - 3*title.height)
    figure.left = (prs_width - figure.width) // 2

    # Add a comment which can be edited later
    comment = slide.shapes.add_textbox(left=0, top=figure.height + title.height, width=prs_width, height=2*pt18_height)
    if comment != None:
        comment.text = comment_txt

    return [slide, title, figure, comment]

def generate_list_data(dir_name) -> list:
    """
    """
    dat = [OpticsData(dir_name+f) for f in listdir(dir_name) if f.endswith('.csv')]
    return dat

def generate_2d_spectrum(dats, key_name, offset=0) -> array:
    """
    Creates a 2-d numpy array from a collection of spectra.

    Parameters
    ----------
    dats : list of OpticsData
        List containing the spectra you wish to stitch

    key_name : str
        Name of the key for the data you wish to stitch, e.g., 'Average Intensity'
        if you want to populate the array with the average intensities of the
        data

    offset : float
        Value to add to all spectra

    Returns
    -------
    spectrum : 2-d NumPy array
        2-d array containing each of the spectra
    """
    spectrum  = zeros((len(dats), len(dats[0].data['Wavelength'])))
    for i in range(len(dats)):
        spectrum[i, :] = dats[i].data[key_name] + offset
    return spectrum

def generate_2d_dR(dats, key_name, background, subtract_mean = True) -> array:
    """
    Creates a 2-d numpy array from a collection of spectra.

    Parameters
    ----------
    dats : list of OpticsData
        List containing the spectra you wish to stitch

    key_name : str
        Name of the key for the data you wish to stitch, e.g., 'Average Intensity'
        if you want to populate the array with the average intensities of the
        data

    background : OpticsData
        OpticsData object containing the reference/background spectrum

    Returns
    -------
    dR : 2-d NumPy array
        2-d array containing each of the differential reflectance spectra
    """
    dR = zeros((len(dats), len(dats[0].data['Wavelength'])))
    for i in range(len(dats)):
        spec = dats[i].data[key_name].divide(dats[i].data[key_name] + background.data['Intensity'])
        if subtract_mean:
            dR[i, :] = spec - mean(spec)
        else:
            dR[i, :] = spec
    return dR

def generate_color_gradient(color1, color2, num_lines) -> list:
    """
    Generate a list of RBG tuples corresponding to the a color gradient between
    color1 and color2. Used for generating a list of colors for plotting with
    a gradient, e.g. from red to blue.

    Parameters
    ----------
    color1, color2 : RGB 3-tuples
        Colors you want to make a gradient between.

    num_lines : int
        Number of lines to plot.

    Returns
    -------
    colors : list of RGB 3-tuples
        List of colors from color1 to color2.
    """
    colors = [(color1[0] + i/num_lines*(color2[0] - color1[0]), 
               color1[1] + i/num_lines*(color2[1] - color1[1]), 
               color1[2] + i/num_lines*(color2[2] - color1[2])) for i in range(num_lines)]
    return colors

#### Plotting utility functions --------------------------------------------

def label_uH_T_X(ax):
    """
    Names the x_label of a plot after the applied magnetic field in Tesla.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the x-axis of.

    Returns
    -------
    N/A
    """
    ax.set_xlabel(r'μ$_0$H (T)')
    return

def label_uH_T_Y(ax):
    """
    Names the x_label of a plot after the applied magnetic field in Tesla.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the x-axis of.

    Returns
    -------
    N/A
    """
    ax.set_ylabel(r'μ$_0$H (T)')
    return

def label_IDC_uA_X(ax):
    """
    Names the x_label of a plot after the DC offset current in μA.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the x-axis of.

    Returns
    -------
    N/A
    """
    ax.set_xlabel(r'I$_{DC}$ (μA)')
    return


def label_wavelength_nm_X(ax):
    """
    Names the x_label of a plot after the collection wavelength in nm.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the x-axis of.

    Returns
    -------
    N/A
    """
    ax.set_xlabel(r'λ (nm)')
    return


def label_energy_eV_X(ax):
    """
    Names the x_label of a plot after the collection energy in eV.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the x-axis of.

    Returns
    -------
    N/A
    """
    ax.set_xlabel(r'$\mathcal{E}$ (eV)')
    return

def label_top_gate_V_X(ax):
    """
    Names the x_label of a plot after the top gate voltage in V.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the x-axis of.

    Returns
    -------
    N/A
    """
    ax.set_xlabel(r'V$_{\text{TG}}$ (V)')

def label_back_gate_V_X(ax):
    """
    Names the x_label of a plot after the top gate voltage in V.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the x-axis of.

    Returns
    -------
    N/A
    """
    ax.set_xlabel(r'V$_{\text{BG}}$ (V)')

def label_top_gate_V_Y(ax):
    """
    Names the x_label of a plot after the top gate voltage in V.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the x-axis of.

    Returns
    -------
    N/A
    """
    ax.set_ylabel(r'V$_{\text{TG}}$ (V)')

def label_back_gate_V_Y(ax):
    """
    Names the x_label of a plot after the top gate voltage in V.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the x-axis of.

    Returns
    -------
    N/A
    """
    ax.set_ylabel(r'V$_{\text{BG}}$ (V)')

def label_int_counts_Y(ax):
    """
    Names the y_label of a plot after the intensity in counts.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the y-axis of.

    Returns
    -------
    N/A
    """
    ax.set_ylabel(r'Intensity (Counts)')
    return

def label_int_au_Y(ax):
    """
    Names the y_label of a plot after the intensity in arbitrary units.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the y-axis of.

    Returns
    -------
    N/A
    """
    ax.set_ylabel(r'Intensity (a.u.)')
    return

def label_dR_R_Y(ax):
    """
    Names the y_label of a plot after the intensity in arbitrary units.

    Parameters
    ----------
    ax : Axes
        Axes object you wish to label the y-axis of.

    Returns
    -------
    N/A
    """
    ax.set_ylabel(r'ΔR/R')
    return